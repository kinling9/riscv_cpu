# 期末报告
## RISCV CPU 设计
### CPU 架构设计
CPU设计的第一步便是根据对应的指令集进行CPU结构的设计，本次设计中的CPU选择的指令集为RISCV指令集。并对于其中32位整数运算指令集RV32I的部分指令进行了实现。其中指令实现参考自RISCV手册。
http://riscvbook.com/RISC-V-Reader-Chinese-v2p1

对于部分error控制和流水线控制指令，例如RV32I中的fence，ecall及csr命令以及对应的csr寄存器。在本文中并未进行实现。因此，对于该CPU，部分来自编译器的中断和流水线控制等指令可能并不能被正常执行。而除去此类指令，其他的指令均在该设计中进行了实现。并且根据课程设计要求，对于RV32I指令集中的and or xor add sub andi ori xori sw lw beq jal指令进行了详细的验证过程。

CPU设计的另一步便是流水线的设计。根据设计要求，CPU需要具有五级流水线，也就是IF,ID,EX,MEM,WB的五级流水级。然而，引入流水线的代价便是流水线执行各种指令过程中存在的诸多冲突问题。

首先，我们考虑此类流水线结构对于跳转指令的处理过程。由于根据RISCV CPU的基本调度结构，其中并不存在MIPS中的指令延时槽结构，而且RV32I指令集中存在着多种多样的比较跳转指令，因此，在指令分支的过程中，必须引入气泡或者流水线停顿使得程序能够按照正确的逻辑运行。而在本设计中，对于B-type类分支跳转指令，分支预测均为不跳转，即直接将后续的指令进行发射，而当指令需要跳转时，再将已经发射但未执行完成的指令进行清除。对于直接的跳转指令jal，jalr，也将使用对应的处理方式。

引入流水线的另一个问题便是数据冲突，当数据未被写回通用寄存器时，对于该寄存器数据的读取过程将会导致错误的计算结果。常见的处理策略为引入数据前馈或者引入流水线等待过程，本设计中采用的策略为流水线等待。也就是在对应数据准备完成之前，流水线将不再发射新的指令，并使存在冲突的指令始终停留在流水线的ID级。

因此，虽然大量的流水线冲突可能会导致CPU对于指令的处理速度降低，但这种设计使得CPU能够高效解决流水线种的数据冲突问题。
### CPU 的组成结构
首先是与CPU结构相关性较低的流水线寄存器flopenrc，总线接口dualport_bus，以及通用寄存器组ram_32x32。这些部件将作为CPU中的基础组成部件。

随后，是按照不同流水级实现各级结构。分别为IF级 riscv_if，ID级 riscv_id 和通用寄存器组riscv_reg，EX级中的riscv_alu，MEM级中的寄存器总线处理模块riscv_mem。由于WB流水级中并不需要逻辑实现，只要进行部分数据选择和连接即可，因此并没有这一模块的单独实现。

最后，是跨流水级的组成结构，首先是接受各级输出结果并对于流水线的流动过程进行控制的冲突控制级riscv_hazard。而riscv_pipeline便是最终实现的完整流水线。这一模块中实例化了冲突解决模块riscv_hazard和前面的各级结构，同时为流水线中的各种传递信息提供了对应的流水线寄存器。

至此，便可以通过DMEM和IMEM来利用该CPU来进行数据处理和其他各种操作。
### CPU 各部分的详细结构及实现策略
在CPU的设计过程中，由于对CPU的组成并不熟悉，因此在本次的设计过程中，我们从CPU的核心部件ALU开始，逐步对各组成结构进行最终的实现过程。
#### EX stage
我们首先明确alu的功能，对于该alu，既需要完成五级流水线中的运算过程，同时对于流水线中的跳转指令，由于跳转指令jalr,beq等命令中均需要对PC进行处理，并将当前地址放入通用寄存器中进行缓存。而对于其他的指令，在RV32I中，所有的指令均为32位，所以pc的变化仅为加4等简单操作，这部分由IF部分一个简单的累加器进行实现。

而在pc的处理过程中，jal相比其他命令更加特殊，由于其目的地址的运算过程不需要读取通用寄存器中的数据，因此在为了减少指令跳转引起的流水线等待时间，其目的pc的计算过程被提前至ID阶段进行，这一操作可以加快CPU在处理跳转指令时的速度。

而数据运算部分的结构相对简单，即从alu输入端口i_num1,i_num2,i_imm_num中接受输入数据，并根据opcode和funct中指定的运算要求来完成进行对应的运算。因此，这一部分的实现为一简单的casex组合逻辑，并将其运算结果在o_num端口中进行输出。

很显然，上述操作均可以使用组合逻辑来完成。因此alu模块并不需要clk和rst输入。
#### ID stage
在完成EX部分的设计后，接下来需要为EX阶段所需的数据进行准备。该部分对应于ID阶段的指令处理以及这一阶段中示例化的32个通用寄存器。
## RISCV CPU 验证
