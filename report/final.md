# 期末报告
## RISCV CPU 设计
### CPU 架构设计
CPU设计的第一步便是根据对应的指令集进行CPU结构的设计，本次设计中的CPU选择的指令集为RISCV指令集。并对于其中32位整数运算指令集RV32I的部分指令进行了实现。其中指令实现参考自RISCV手册。
http://riscvbook.com/RISC-V-Reader-Chinese-v2p1

对于部分error控制和流水线控制指令，例如RV32I中的fence，ecall及csr命令以及对应的csr寄存器。在本文中并未进行实现。因此，对于该CPU，部分来自编译器的中断和流水线控制等指令可能并不能被正常执行。而除去此类指令，其他的指令均在该设计中进行了实现。并且根据课程设计要求，对于RV32I指令集中的and or xor add sub andi ori xori sw lw beq jal指令进行了详细的验证过程。

CPU设计的另一步便是流水线的设计。根据设计要求，CPU需要具有五级流水线，也就是IF,ID,EX,MEM,WB的五级流水级。然而，引入流水线的代价便是流水线执行各种指令过程中存在的诸多冲突问题。

首先，我们考虑此类流水线结构对于跳转指令的处理过程。由于根据RISCV CPU的基本调度结构，其中并不存在MIPS中的指令延时槽结构，而且RV32I指令集中存在着多种多样的比较跳转指令，因此，在指令分支的过程中，必须引入气泡或者流水线停顿使得程序能够按照正确的逻辑运行。而在本设计中，对于B-type类分支跳转指令，分支预测均为不跳转，即直接将后续的指令进行发射，而当指令需要跳转时，再将已经发射但未执行完成的指令进行清除。对于直接的跳转指令jal，jalr，也将使用对应的处理方式。

引入流水线的另一个问题便是数据冲突，当数据未被写回通用寄存器时，对于该寄存器数据的读取过程将会导致错误的计算结果。常见的处理策略为引入数据前馈或者引入流水线等待过程，本设计中采用的策略为流水线等待。也就是在对应数据准备完成之前，流水线将不再发射新的指令，并使存在冲突的指令始终停留在流水线的ID级。

因此，虽然大量的流水线冲突可能会导致CPU对于指令的处理速度降低，但这种设计使得CPU能够高效解决流水线种的数据冲突问题。
### CPU 的组成结构
首先是与CPU结构相关性较低的流水线寄存器flopenrc，总线接口dualport_bus，以及通用寄存器组ram_32x32。这些部件将作为CPU中的基础组成部件。

随后，是按照不同流水级实现各级结构。分别为IF级 riscv_if，ID级 riscv_id 和通用寄存器组riscv_reg，EX级中的riscv_alu，MEM级中的寄存器总线处理模块riscv_mem。由于WB流水级中并不需要逻辑实现，只要进行部分数据选择和连接即可，因此并没有这一模块的单独实现。

最后，是跨流水级的组成结构，首先是接受各级输出结果并对于流水线的流动过程进行控制的冲突控制级riscv_hazard。而riscv_pipeline便是最终实现的完整流水线。这一模块中实例化了冲突解决模块riscv_hazard和前面的各级结构，同时为流水线中的各种传递信息提供了对应的流水线寄存器。

至此，便可以通过DMEM和IMEM来利用该CPU来进行数据处理和其他各种操作。
### CPU 各部分的详细结构及实现策略
在CPU的设计过程中，由于对CPU的组成并不熟悉，因此在本次的设计过程中，我们从CPU的核心部件ALU开始，逐步对各组成结构进行最终的实现过程。
#### EX stage
我们首先明确alu的功能，对于该alu，既需要完成五级流水线中的运算过程，同时对于流水线中的跳转指令，由于跳转指令jalr,beq等命令中均需要对PC进行处理，并将当前地址放入通用寄存器中进行缓存。而对于其他的指令，在RV32I中，所有的指令均为32位，所以pc的变化仅为加4等简单操作，这部分由IF部分一个简单的累加器进行实现。

而在pc的处理过程中，jal相比其他命令更加特殊，由于其目的地址的运算过程不需要读取通用寄存器中的数据，因此在为了减少指令跳转引起的流水线等待时间，其目的pc的计算过程被提前至ID阶段进行，这一操作可以加快CPU在处理跳转指令时的速度。

而数据运算部分的结构相对简单，即从alu输入端口i_num1,i_num2,i_imm_num中接受输入数据，并根据opcode和funct中指定的运算要求来完成进行对应的运算。因此，这一部分的实现为一简单的casex组合逻辑，并将其运算结果在o_num端口中进行输出。

很显然，上述操作均可以使用组合逻辑来完成。因此alu模块并不需要clk和rst输入。
#### ID stage
在完成EX部分的设计后，接下来需要为EX阶段所需的数据进行准备。该部分对应于ID阶段的指令处理模块以及在这一阶段中示例化的32个通用寄存器。

很显然，通用寄存器模块不能使用时序逻辑实现，因此，在对于ram_32x32基础模块进行实现时，使用的是理想的组合逻辑，即默认输入的数据可以立刻被读出。而对于这一部分中可能存在的冲突并没有进行处理。因此，这一部分的设计可能存在一定的问题。而为了将ram_32x32存储器模块与其他外部组件进行连接，我们通过riscv_reg模块来进行这一处理过程。同时，在该模块中，我们通过override避免了对于寄存器0的读写操作，使得无论任何时候对其进行读取，读到的数据永远为0。

该模块的另一个重要组成部分便是译码模块riscv_id，该模块的输入只有IF部分传递过来的32位指令。而在这一模块中，需要根据指令的类别对于其中的数据进行识别和读取，例如用于立即数运算的立即数，需要进行数据读取的寄存器地址，进行数据读取或者写入的内存地址等。同时，多个周期后的寄存器写入信号也需要由此模块产生，随后在多个周期后通过流水线寄存器再度传递到riscv_reg模块。

通过这两个组件，我们便能够为EX阶段提供数据运算的数据以及对应的控制指令。而用于跳转运算的pc值，仍需要IF阶段来提供。

#### IF stage
IF阶段为指令的发射级，同时也是整个流水线的起点。在我们的设计中，CPU在这一阶段不对当前拿到的指令进行任何的处理，因此，这一模块需要完成的任务便是根据后续产生的控制信号来指导指令的发射。

首先需要明确后续的控制信号有哪些，首先，根据前文中对于数据冲突的分析，当发生数据冲突时，CPU需要暂停发射来等待先前运算或读取结果的写回过程。因此，IF阶段必须要有一个停顿信号来阻止指令的发射过程。

而对于跳转指令，这类指令将直接改变IF阶段进行发射的指令顺序。因此，此类指令需要提供跳转的位置来控制指令的发射过程。同时，由于两种不同跳转指令（J-type，B-type）的存在，该阶段将接受两组不同的跳转地址并按照优先级进行判断。

而当该模块未接受到上述控制指令时，直接将拿到的指令发射给下一级。

#### dual_port bus
在IF阶段，便需要设计和外部连接的接口。同时，考虑到指令ROM和RAM的相似性，决定为DMEM和IMEM设计相同的接口。因此，这一接口需要满足读操作和写操作的需求。然而，由于CPU并不会使用指令bus对于指令ROM进行写入，在IMEM中，其写操作结构会始终处于关闭状态。最终设计的接口如下所示：
```
  // read interface
  logic  rd_req, rd_gnt;
  logic  [3:0]  rd_be;
  logic  [31:0] rd_addr, rd_data;
  // write interface
  logic  wr_req, wr_gnt;
  logic  [3:0]  wr_be;
  logic  [31:0] wr_addr, wr_data;
```
通过be对于读写过程中的比特位进行控制，而req和gnt则被用于确定总线的工作状态。通过该接口，便可以进行指令和内存数据的读取过程。这一结构在IF阶段和MEM阶段得到了实际的应用。

#### MEM stage
MEM阶段负责CPU和内存之间的数据交互。在这一阶段中，需要根据指令的类型进行读写过程中的比特对齐。为了满足存储器对齐的数据读取需求，进行读取的存储器地址始终保持低两位为0。而该模块将根据读取的地址来选择合适的be值来选择对应的比特位。

同样的，对于读到的数据，也要根据be值来对数据进行处理。不同的load指令的扩展方式也不尽相同，因此，这一阶段同样需要根据指令中的funct值选择不同的行为。但RISCV指令在设计的过程中便考虑到了这一因素。对于符号数和无符号数的load指令，其差距只存在于funct3值中，因此只需要将funct3沿流水线传递到这一级即可进行正确的符号扩展过程。

在总线的设计中，预留的总线信号req和gnt表示了数据的准备状态。当请求信号req=1而gnt=0时，表示对于RAM的数据请求已经发出，但并未从RAM中读取到对应的数据，因此，这时流水线必须停下来等待RAM中的数据读取，否则一个位置来源的信号将替代RAM中读到的数据被写入到寄存器组中。这一信号o_bus_stall将会由冲突解决模块进行处理，并对于所有的流水线寄存器进行控制，以实现流水线的等待过程。
#### hazard module
前述模块设计完成后，便需要依据可能存在的数据冲突来设计hazard模块。首先对于数据冲突，常见的三种数据冲突为写后写，写后读，读后写。而对于该设计中的五级流水线，由于其写入操作均在WB阶段完成，而且并未构造具有乱序发射能力的发射组件，因此只需要考虑写后读冲突即可，其它两种冲突并不会发生。

为了避免写后读冲突，在hazard模块中，需要使用组合逻辑实时对比当前正在读取的寄存器地址和尚未被写入的寄存器地址是否一致，若存在一致的情况，则需要在流水线中引入气泡，使得存在数据冲突的指令不会被推入EX阶段。同时，IF阶段的指令发射也将进入等待状态，即此时将保持pc值不发生改变，否则将导致指令读取的错误。

跳转指令的处理方式和
## RISCV CPU 验证
### 基于testbench的初步验证
### 基于UVM的高覆盖率验证
