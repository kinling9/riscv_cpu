### Initial design for EX
1. 对于一个riscv处理器设计，首先设计其使用的alu，首先明确alu的功能，对于该alu，既需要完成五级流水线中的运算过程，同时对于流水线中的跳转指令，由于跳转指令jal,jalr,beq等命令中均需要对PC进行处理，而对于其他的指令，在本设计中，所有的指令均为32位，所以pc的变化仅为加4等简单操作，这部分由ID部分一个简单的加法器进行实现。
> 对于riscv处理器，其数据存储方式为小端序，也就是高位会放在后面，对于uj格式的跳转指令jal，其30-12位实现了1-29位跳转offset的立即数的存储而立即数的第20位被存储在第31位上，参考图像为J格式指令的分划。
2. 考虑输入内容，输入内容可以分为需要进行运算的数据和控制运算种类的控制指令，运算数据较为简单，对于寄存器间的运算（包括比较运算），所需要的运算数据位通用寄存器组的对应数据，即rs1,rs2。而对于立即数运算，需要接收经过符号扩展的立即数。而对于跳转指令，则需要获得当前的pc指针。因此需要支持的主要输入数据便是上述部分。而控制指令，根据RISCV中一般的定义规则，对于R-type指令，控制指令最多，分别为opcode的7位以及12-14位的funct3以及25-31位的funct7，我们选择将这些控制指令全部输入进去，用于实现最终alu运算过程的控制。
3. 对于输出部分，首先是分支指令的跳转与否，随后是ALU的结果输出，为了将跳转指令与运算指令分开，我们为PC指针和ALU结果设置不同的输出端口。
4. 流水线的清空部分暂未进行设计，可能会使用local的rst操作来实现？该部分等到最终的五级流水线搭建完成后进行统一的测试过程

### Else design for EX
1. 对于ALU，其仅完成计算的过程，对于进位的部分并未进行运算，然而查阅部分资料，发现对于RISCV CPU，进位溢出是由软件进行检测的，因此在ALU设计的过程中无需考虑。
2. 对于J指令，由于jal，jalr均需要将跳转前的PC+4储存在寄存器rd中，该部分的输出将使用ALU的主output主输出o_num进行输出
3. 对于比较指令，由于需要同时支持有符号数和无符号数的比较过程，尝试使用verilog中定义的\$signed函数，暂不清楚该写法是否可以综合 *FIXME*
4. 对于load，store指令，由于其只需要完成取数的操作过程，因此可能不需要在ALU中实现 *FIXME*